*********************************************************************************************************

PRBS BER Fiber Optics Project

*********************************************************************************************************

- Background

This repository documents the design and implementation of a FPGA based bit error rate tester.
The BER tester generates a pseudo random bitstream with an injected error rate that is then received 
and compared to a PRBS generated with the same equation. This tester was designed as part of a fiber 
optics project and was used with a fiber optic TX and RX, but can be applied to any system that could 
generate bit errors.

- Software

This project was developed, simulated, synthesized, and implemented using Vivado 2022.2. Additionally
the IPs used for this project are Xilinx property and are included in Vivado. All code was written in 
system verilog.

- Files

The files used for this project are instantiated in a top.sv file allowing the different modules to be
used separately if desired. In addition to the files instantiated in the top module a constraint file is
needed to map the variables used in the code to hardware inputs and outputs on your actual FPGA. 

	- Top.sv
	The top module defines variables shared across other modules and instantiates other modules used in 
	the project.

		- PRBS_Generator.sv
		The generator module generates the pseudo random bitstream that will be sent through the system
		being tested by the device and injects a known bit error rate into this bitstream. 

		- PRBS_Reciver.sv 
		The receiver modules receives the bitstream at the output of the system being tested and saves a
		section of the received bitstream which it then uses to generate its own bitstream without errors. 
		It then compares the errorless bitstream generated by this module to the received bitstream and 
		counts the total number of bits received as well as the number of error bits received to find the
		bit error rate.

		- Control.sv
		The control module interfaces the other modules and instantiated IPs with the AXI buses used on
		the FPGA development board which allows the modules and IPs to communicate.

		- axi_uartlite_0.xci
		The uartlite IP is used to communicate with an outside computer to receive the bit error rate data
		measured by the tester. This IP is configured with 8 data bits and an AXI frequency of 100 Mhz
		* NOTE * 
		If implementing this system you need to use vivado to generate this IP yourself as including all
		files generated by the IP in this repository is impractical

		- clk_wiz_1.xci
		The clock wizard IP is used to generate the 100 Mhz system clock from the clk on the development 
		board. The IP is configured with a generated clock of 100 Mhz. The input clock is based on the 
		development board you are using.
		* NOTE * 
		If implementing this system you need to use vivado to generate this IP yourself as including all
		files generated by the IP in this repository is impractical

	- PYNQ-Z2 v1.0.xdc
	This constraint file is used to assign variable names to physical outputs on the development board. 
	Mine is for the PYNQ-Z2 development board. If implementing this design on a different development board 
	or FPGA you will need a completely different constraint file.

- Device

This project was designed for implementation on the PYNQ-Z2 development board, but should be able to be 
implemented on any development board or FPGA. If implementing on anything other than a PYNQ-Z2 you will need 
a completely different constraint file as each constraint file is specific to the device the design is being
implemented on. It is possible you will need to tweak other parts of your design depending on the device you
want to implement this design on.

- Hardware

To implement this design you will need an FPGA or an FPGA development board, a physical connection to connect
to the FPGA and instantiate the design, a way to power your FPGA or development board, and a connection to 
send UART to a computer to receive the measured data. 
* NOTE * 
If intending to implement this design on an FPGA that is not on a development board you will need to provide
things that are built in to a typical development board such as a power supply, integrated clock, etc.
* NOTE * 
This design can be implemented on an FPGA that is not made by Xilinx but may require adaptation.
